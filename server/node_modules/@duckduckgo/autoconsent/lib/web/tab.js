import { waitFor } from "../cmps/base";
import { enableLogs } from "../config";
export default class TabActions {
    constructor(tabId, frame, sendContentMessage, browser) {
        this.frame = frame;
        this.sendContentMessage = sendContentMessage;
        this.browser = browser;
        this.id = tabId;
    }
    async elementExists(selector, frameId = 0) {
        return this.sendContentMessage(this.id, {
            type: "elemExists",
            selector
        }, {
            frameId
        });
    }
    async clickElement(selector, frameId = 0) {
        enableLogs && console.log(`click element ${selector} in tab ${this.id}`);
        return this.sendContentMessage(this.id, {
            type: "click",
            selector
        }, {
            frameId
        });
    }
    async clickElements(selector, frameId = 0) {
        enableLogs && console.log(`click elements ${selector} in tab ${this.id}`);
        return this.sendContentMessage(this.id, {
            type: "click",
            all: true,
            selector
        }, {
            frameId
        });
    }
    async elementsAreVisible(selector, check, frameId = 0) {
        return this.sendContentMessage(this.id, {
            type: "elemVisible",
            selector,
            check
        }, {
            frameId
        });
    }
    async getAttribute(selector, attribute, frameId = 0) {
        return this.sendContentMessage(this.id, {
            type: "getAttribute",
            selector,
            attribute
        }, { frameId });
    }
    async eval(script, frameId = 0) {
        // console.log(`run ${script} in tab ${this.id}`);
        return await this.sendContentMessage(this.id, {
            type: "eval",
            script
        }, { frameId });
    }
    async waitForElement(selector, timeout, frameId = 0) {
        const interval = 200;
        const times = Math.ceil(timeout / interval);
        return waitFor(() => this.elementExists(selector, frameId), times, interval);
    }
    async waitForThenClick(selector, timeout, frameId = 0) {
        if (await this.waitForElement(selector, timeout, frameId)) {
            return await this.clickElement(selector, frameId);
        }
        return false;
    }
    async hideElements(selectors, frameId = 0, method = 'display') {
        enableLogs && console.log('Sending hide elements to', this.id, selectors);
        return this.sendContentMessage(this.id, {
            type: "hide",
            selectors,
            method,
        }, { frameId });
    }
    async undoHideElements(frameId = 0) {
        return this.sendContentMessage(this.id, {
            type: "undohide",
        }, { frameId });
    }
    async getBrowserTab() {
        return this.browser.tabs.get(this.id);
    }
    async goto(url) {
        return this.browser.tabs.update(this.id, { url });
    }
    wait(ms) {
        enableLogs && console.log(`waiting for ${ms}ms in tab ${this.id}`);
        return new Promise(resolve => {
            setTimeout(() => {
                enableLogs && console.log(`done waiting in tab ${this.id}`);
                resolve(true);
            }, ms);
        });
    }
    matches(matcherConfig) {
        return this.sendContentMessage(this.id, {
            type: "matches",
            config: matcherConfig
        }, { frameId: 0 });
    }
    executeAction(config, param) {
        return this.sendContentMessage(this.id, {
            type: "executeAction",
            config,
            param
        }, { frameId: 0 });
    }
}
