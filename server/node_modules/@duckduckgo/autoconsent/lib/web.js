import Tab from './web/tab';
import handleContentMessage from './web/content';
import TabConsent from './tabwrapper';
import detectDialog from './detector';
import { rules, createAutoCMP } from './index';
import { ConsentOMaticCMP } from './consentomatic/index';
import prehideElements from './hider';
import { enableLogs } from './config';
export * from './index';
export { Tab, handleContentMessage, };
export default class AutoConsent {
    constructor(browser, sendContentMessage) {
        this.browser = browser;
        this.sendContentMessage = sendContentMessage;
        this.consentFrames = new Map();
        this.tabCmps = new Map();
        this.sendContentMessage = sendContentMessage;
        this.rules = [...rules];
    }
    addCMP(config) {
        this.rules.push(createAutoCMP(config));
    }
    disableCMPs(cmpNames) {
        this.rules = this.rules.filter((cmp) => !cmpNames.includes(cmp.name));
    }
    addConsentomaticCMP(name, config) {
        this.rules.push(new ConsentOMaticCMP(`com_${name}`, config));
    }
    createTab(tabId) {
        return new Tab(tabId, this.consentFrames.get(tabId), this.sendContentMessage, this.browser);
    }
    async checkTab(tabId, prehide = true) {
        enableLogs && console.log('checking tab', tabId, this.consentFrames, this.tabCmps);
        const tab = this.createTab(tabId);
        if (prehide) {
            this.prehideElements(tab);
        }
        const consent = new TabConsent(tab, this.detectDialog(tab, 20));
        this.tabCmps.set(tabId, consent);
        // check tabs
        consent.checked.then((rule) => {
            if (this.consentFrames.has(tabId) && rule) {
                const frame = this.consentFrames.get(tabId);
                enableLogs && console.log(`Found ${rule.name} in a nested iframe ${frame.id} inside tab ${tabId}`);
                if (frame.type === rule.name) {
                    consent.tab.frame = frame;
                }
            }
            enableLogs && console.log('finished checking tab', tabId, this.consentFrames, this.tabCmps);
            // no CMP detected, undo hiding
            if (!rule && prehide) {
                enableLogs && console.log('no CMP detected, undo hiding');
                tab.undoHideElements();
            }
        });
        return this.tabCmps.get(tabId);
    }
    removeTab(tabId) {
        this.tabCmps.delete(tabId);
        this.consentFrames.delete(tabId);
    }
    onFrame({ tabId, url, frameId }) {
        // ignore main frames
        if (frameId === 0) {
            return;
        }
        try {
            const frame = {
                id: frameId,
                url: url,
            };
            const tab = this.createTab(tabId);
            const frameMatch = this.rules.findIndex(r => r.detectFrame(tab, frame));
            if (frameMatch > -1) {
                this.consentFrames.set(tabId, {
                    type: this.rules[frameMatch].name,
                    url,
                    id: frameId,
                });
                if (this.tabCmps.has(tabId)) {
                    this.tabCmps.get(tabId).tab.frame = this.consentFrames.get(tabId);
                }
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    async detectDialog(tab, retries) {
        return detectDialog(tab, retries, this.rules);
    }
    async prehideElements(tab) {
        return prehideElements(tab, this.rules);
    }
}
